#!/usr/bin/env bb
(ns brepl.lib.file-tracker
  "Track file changes across tool uses for automatic REPL reloading.
   Uses mtime (modification time) for O(n) stat calls instead of reading files."
  (:require [babashka.fs :as fs]
            [clojure.java.io :as io]
            [clojure.edn :as edn]
            [clojure.string :as str]))

(defn find-clojure-files
  "Find all Clojure files in the given directory (default: cwd).
   Excludes common non-source directories."
  ([] (find-clojure-files "."))
  ([dir]
   (let [excluded-dirs #{".git" "node_modules" "target" ".cpcache" ".clj-kondo" ".lsp"}]
     (->> (fs/glob dir "**/*.{clj,cljs,cljc,edn}")
          (remove (fn [path]
                    (some #(str/includes? (str path) (str "/" % "/"))
                          excluded-dirs)))
          (map str)
          (filter #(.isFile (io/file %)))
          vec))))

(defn file-mtime
  "Get file modification time in millis. Returns nil if file doesn't exist."
  [path]
  (when (fs/exists? path)
    (fs/file-time->millis (fs/last-modified-time path))))

(defn mtime-all-files
  "Get mtime for all given files. Returns map of path -> mtime."
  [file-paths]
  (->> file-paths
       (map (fn [path] [path (file-mtime path)]))
       (into {})))

(defn state-file
  "Get the state file path for a session."
  [session-id]
  (let [dir (io/file "/tmp" (str "brepl-tracker-" session-id))]
    (.mkdirs dir)
    (io/file dir "mtimes.edn")))

(defn save-mtimes
  "Save file mtimes for a session."
  [session-id mtimes]
  (spit (state-file session-id) (pr-str mtimes)))

(defn load-mtimes
  "Load saved file mtimes for a session."
  [session-id]
  (let [f (state-file session-id)]
    (when (.exists f)
      (edn/read-string (slurp f)))))

(defn detect-changes
  "Compare current mtimes with saved mtimes.
   Returns vector of changed file paths (modified or new files)."
  [session-id]
  (let [saved (load-mtimes session-id)]
    (when saved
      (let [current-files (find-clojure-files)
            current (mtime-all-files current-files)]
        (->> current
             (filter (fn [[path mtime]]
                       (let [old-mtime (get saved path)]
                         ;; Changed if: new file (no old-mtime) or mtime differs
                         (or (nil? old-mtime)
                             (not= old-mtime mtime)))))
             (map first)
             vec)))))

(defn snapshot!
  "Take a snapshot of all Clojure files in the project.
   Returns the number of files tracked."
  [session-id]
  (let [files (find-clojure-files)
        mtimes (mtime-all-files files)]
    (save-mtimes session-id mtimes)
    (count files)))

(defn cleanup-state
  "Clean up tracking state for a session."
  [session-id]
  (let [dir (io/file "/tmp" (str "brepl-tracker-" session-id))]
    (when (.exists dir)
      (doseq [file (.listFiles dir)]
        (.delete file))
      (.delete dir))))
(ns brepl.lib.stop-hooks
  "Stop hook execution for Claude Code Stop event."
  (:require [clojure.java.io :as io]
            [clojure.edn :as edn]
            [clojure.spec.alpha :as s]
            [clojure.string :as str]
            [babashka.process :as process]))

;; =============================================================================
;; Specs for hook validation
;; =============================================================================

;; Common fields (same for REPL and bash)
(s/def ::type #{:repl :bash})
(s/def ::name string?)
(s/def ::required? boolean?)        ;; If true: retry on failure. If false: inform and proceed.
(s/def ::max-retries (s/and int? (complement neg?)))
(s/def ::timeout pos-int?)

;; REPL-specific - code can be string or s-expression
(s/def ::code (s/or :string string? :form list? :symbol symbol?))

;; Bash-specific
(s/def ::command string?)
(s/def ::cwd string?)
(s/def ::env (s/map-of string? string?))

;; Hook specs by type
(s/def ::repl-hook
  (s/keys :req-un [::type ::code]
          :opt-un [::name ::required? ::max-retries ::timeout]))

(s/def ::bash-hook
  (s/keys :req-un [::type ::command]
          :opt-un [::name ::required? ::max-retries ::timeout ::cwd ::env]))

(s/def ::hook
  (s/or :repl (s/and ::repl-hook #(= (:type %) :repl))
        :bash (s/and ::bash-hook #(= (:type %) :bash))))

(s/def ::stop (s/coll-of ::hook))

(s/def ::hooks-config
  (s/keys :opt-un [::stop]))

;; =============================================================================
;; Default values
;; =============================================================================

(def defaults
  {:required? false
   :max-retries 10
   :timeout 60
   :cwd "."
   :env {}})

(defn derive-name
  "Derive hook name from command or code if not provided."
  [hook]
  (or (:name hook)
      (let [raw (or (:command hook) (:code hook) "hook")
            source (if (string? raw) raw (pr-str raw))
            truncated (subs source 0 (min 30 (count source)))]
        (if (< (count source) 30) truncated (str truncated "...")))))

(defn apply-defaults
  "Apply default values to a hook."
  [hook]
  (-> (merge defaults hook)
      (assoc :name (derive-name hook))))

;; =============================================================================
;; Configuration loading
;; =============================================================================

(def hooks-file ".brepl/hooks.edn")

(defn load-hooks
  "Load and parse .brepl/hooks.edn. Returns {:stop [...]} or nil if not found."
  []
  (let [f (io/file hooks-file)]
    (when (.exists f)
      (try
        (edn/read-string (slurp f))
        (catch Exception e
          {:error (.getMessage e)})))))

;; =============================================================================
;; Validation
;; =============================================================================

(defn format-hook-error
  "Format a single hook validation error in human-readable form."
  [hook idx]
  (let [hook-type (:type hook)
        problems (cond-> []
                   ;; Type validation
                   (not (#{:repl :bash} hook-type))
                   (conj (str "invalid :type " (pr-str hook-type) " (must be :repl or :bash)"))

                   ;; REPL hook needs :code
                   (and (= hook-type :repl) (not (:code hook)))
                   (conj "missing :code field")

                   ;; Bash hook needs :command
                   (and (= hook-type :bash) (not (:command hook)))
                   (conj (if (:cmd hook)
                           "has :cmd but should be :command"
                           "missing :command field"))

                   ;; Type checks for optional fields
                   (and (:timeout hook) (not (pos-int? (:timeout hook))))
                   (conj ":timeout must be a positive integer")

                   (and (:max-retries hook) (not (and (int? (:max-retries hook))
                                                       (>= (:max-retries hook) 0))))
                   (conj ":max-retries must be a non-negative integer")

                   (and (contains? hook :required?) (not (boolean? (:required? hook))))
                   (conj ":required? must be true or false"))]
    (when (seq problems)
      (str "Hook " (inc idx) ": " (str/join ", " problems)))))

(defn format-validation-errors
  "Format spec errors into human-readable messages."
  [config]
  (let [hooks (get config :stop [])]
    (->> hooks
         (map-indexed (fn [idx hook] (format-hook-error hook idx)))
         (remove nil?)
         (str/join "\n"))))

(defn validate-hooks
  "Validate hooks config against specs.
   Returns {:valid? true/false :errors str}."
  [config]
  (if (s/valid? ::hooks-config config)
    {:valid? true :errors nil}
    {:valid? false
     :errors (format-validation-errors config)}))

;; =============================================================================
;; State persistence (retry tracking)
;; =============================================================================

(defn state-file-path
  "Get path to state file for a session."
  [session-id]
  (str "/tmp/brepl-stop-hook-" session-id ".edn"))

(defn read-state
  "Read retry state from file. Returns map of hook-name -> retry-count."
  [session-id]
  (let [f (io/file (state-file-path session-id))]
    (if (.exists f)
      (try
        (edn/read-string (slurp f))
        (catch Exception _
          {}))
      {})))

(defn write-state
  "Write retry state to file."
  [session-id state]
  (spit (state-file-path session-id) (pr-str state)))

(defn cleanup-state
  "Remove state file."
  [session-id]
  (let [f (io/file (state-file-path session-id))]
    (when (.exists f)
      (.delete f))))

;; =============================================================================
;; Bash hook execution
;; =============================================================================

(defn execute-bash-hook
  "Execute shell command via babashka.process.
   Returns {:success? bool :stdout str :stderr str :exit int}."
  [hook]
  (let [{:keys [command cwd env timeout]} (apply-defaults hook)
        timeout-ms (* timeout 1000)]
    (try
      ;; Use sh -c to run command through shell for proper expansion
      (let [result (process/shell {:out :string
                                   :err :string
                                   :dir cwd
                                   :extra-env env
                                   :timeout timeout-ms
                                   :continue true}  ;; Don't throw on non-zero exit
                                  "sh" "-c" command)]
        {:success? (zero? (:exit result))
         :stdout (:out result)
         :stderr (:err result)
         :exit (:exit result)})
      (catch java.util.concurrent.TimeoutException _
        {:success? false
         :stdout ""
         :stderr (str "Hook timed out after " timeout " seconds")
         :exit -1})
      (catch Exception e
        {:success? false
         :stdout ""
         :stderr (.getMessage e)
         :exit -1}))))

;; =============================================================================
;; REPL hook execution
;; =============================================================================

;; Forward declaration - will be set by brepl main when loading
(def ^:dynamic *nrepl-eval-fn* nil)
(def ^:dynamic *resolve-port-fn* nil)
(def ^:dynamic *resolve-host-fn* nil)

(defn connection-error?
  "Check if error indicates nREPL server is not running."
  [error-str]
  (and error-str
       (or (str/includes? error-str "Connection refused")
           (str/includes? error-str "Connection reset"))))

(defn execute-repl-hook
  "Execute Clojure code via nREPL.
   Returns {:success? bool :output str :error str :no-server? bool}."
  [hook]
  (let [{:keys [code timeout required?]} (apply-defaults hook)
        ;; Code can be string or s-expression - convert to string for nREPL
        code-str (if (string? code) code (pr-str code))
        port (when *resolve-port-fn* (*resolve-port-fn* nil nil))
        host (when *resolve-host-fn* (*resolve-host-fn* nil))]
    (cond
      ;; No port available
      (nil? port)
      (if required?
        {:success? false
         :output ""
         :error "Inform the user that the hook won't work because nREPL server is not running. Offer to start it or ask the user to do it."
         :no-server? true}
        {:success? true
         :output ""
         :error nil
         :skipped? true})

      ;; Have port, execute
      *nrepl-eval-fn*
      (try
        (let [timeout-ms (* timeout 1000)
              result-future (future (*nrepl-eval-fn* host port code-str {:hook true}))
              result (deref result-future timeout-ms ::timeout)]
          (if (= result ::timeout)
            {:success? false
             :output ""
             :error (str "Hook timed out after " timeout " seconds")}
            (let [{:keys [processed has-error?]} result
                  output (str/join "\n" (concat (:out processed) (:values processed)))
                  ;; Combine exception class and stderr for full error context
                  error-msg (when has-error?
                              (let [parts (cond-> []
                                            (:ex processed) (conj (:ex processed))
                                            (seq (:err processed)) (into (:err processed)))]
                                (if (seq parts)
                                  (str/join "\n" parts)
                                  "Evaluation error")))]
              ;; Check for connection errors (stale .nrepl-port file)
              (if (connection-error? error-msg)
                {:success? false
                 :output ""
                 :error "Inform the user that the hook won't work because nREPL server is not running. Offer to start it or ask the user to do it."
                 :no-server? true}
                {:success? (not has-error?)
                 :output output
                 :error error-msg}))))
        (catch Exception e
          (let [msg (.getMessage e)]
            (if (connection-error? msg)
              {:success? false
               :output ""
               :error "Inform the user that the hook won't work because nREPL server is not running. Offer to start it or ask the user to do it."
               :no-server? true}
              {:success? false
               :output ""
               :error msg}))))

      :else
      {:success? false
       :output ""
       :error "nREPL eval function not initialized"})))

;; =============================================================================
;; Main orchestration
;; =============================================================================

(defn execute-hook
  "Execute a single hook (REPL or bash).
   Returns {:success? bool :output str :error str :no-server? bool}."
  [hook]
  (case (:type hook)
    :repl (execute-repl-hook hook)  ;; Returns :no-server? when nREPL unavailable
    :bash (let [result (execute-bash-hook hook)
                stdout (str/trim (or (:stdout result) ""))
                stderr (str/trim (or (:stderr result) ""))
                ;; Combine output for error context (Claude needs to see what failed)
                combined-output (str/join "\n" (remove str/blank? [stdout stderr]))]
            {:success? (:success? result)
             :output stdout
             :error (when-not (:success? result)
                      (if (str/blank? combined-output)
                        (str "Exit code " (:exit result))
                        (str "Exit code " (:exit result) "\n" combined-output)))})))

(defn run-stop-hooks
  "Main orchestration function.
   Takes session-id and hooks config.
   Returns {:exit-code 0|1|2 :message str}."
  [session-id config]
  (let [hooks (mapv apply-defaults (get config :stop []))]
    (if (empty? hooks)
      {:exit-code 0 :message "No hooks configured"}
      (let [state (read-state session-id)]
        (loop [remaining hooks
               current-state state]
          (if (empty? remaining)
            ;; All hooks passed
            (do
              (cleanup-state session-id)
              {:exit-code 0 :message "All hooks passed"})
            (let [hook (first remaining)
                  hook-name (:name hook)
                  result (execute-hook hook)]
              (cond
                ;; Hook passed - reset retry count, continue
                (:success? result)
                (recur (rest remaining)
                       (dissoc current-state hook-name))

                ;; No server - first time: block (exit 2), second time: inform (exit 1)
                (:no-server? result)
                (let [no-server-key "__no-server__"
                      seen-before? (contains? current-state no-server-key)]
                  (if seen-before?
                    ;; Second attempt - allow stopping
                    (do
                      (cleanup-state session-id)
                      {:exit-code 1
                       :message (:error result)})
                    ;; First attempt - block, force Claude to react
                    (do
                      (write-state session-id (assoc current-state no-server-key true))
                      {:exit-code 2
                       :message (:error result)})))

                ;; Hook failed - check retry logic
                :else
                (let [required? (:required? hook)
                      max-retries (:max-retries hook)
                      current-retries (get current-state hook-name 0)
                      new-retries (inc current-retries)
                      infinite-retries? (zero? max-retries)
                      within-limit? (or infinite-retries? (< current-retries max-retries))]
                  (if (and required? within-limit?)
                    ;; Required hook - retry (exit 2 to make Claude continue)
                    (do
                      (write-state session-id (assoc current-state hook-name new-retries))
                      {:exit-code 2
                       :message (str "Hook '" hook-name "' failed (attempt " new-retries
                                     (when-not infinite-retries?
                                       (str "/" max-retries))
                                     "). Fix the issues shown below and try again:\n"
                                     (:error result))})
                    ;; Optional hook or limit reached - inform (exit 1)
                    (do
                      (write-state session-id (dissoc current-state hook-name))
                      {:exit-code 1
                       :message (if (and required? (not within-limit?))
                                  (str "Hook '" hook-name "' failed after " max-retries " retries: " (:error result))
                                  (str "Hook '" hook-name "' failed: " (:error result)))})))))))))))(ns brepl.lib.skill-content
  "Embedded skill content for uberscript distribution.")

(def skill-md
  "---
name: brepl
description: \"MANDATORY - Load this skill BEFORE using brepl in any way. Teaches the heredoc pattern for reliable code evaluation.\"
---

# brepl - Evaluating Clojure Code

## CRITICAL: Load This Skill First

**You MUST load this skill before using brepl.** Do NOT attempt to use brepl without loading this skill first, or you will use incorrect syntax.

## Overview

brepl is a REPL client for evaluating Clojure expressions. This skill teaches the heredoc pattern for reliable code evaluation.

**Always load this skill before using brepl. Always use the heredoc pattern for all Clojure code evaluation.**

## The Heredoc Pattern - Default Approach

**Always use heredoc for brepl evaluation.** This eliminates quoting issues, works for all cases, and provides a consistent, reliable pattern.

### Syntax (Stdin - Recommended)

```bash
brepl <<'EOF'
(your clojure code here)
EOF
```

This is the simplest heredoc syntax - stdin feeds directly to brepl.

### Alternative Syntax (Positional Argument)

For simple one-liners, you can use positional arguments:

```bash
brepl '(+ 1 2 3)'
```

Heredoc is preferred for anything with quotes or multiple lines.

**Note**: The `-e` flag is optional - brepl automatically treats stdin and positional arguments as code to evaluate.

**Important**: Use `<<'EOF'` (with quotes) not `<<EOF` to prevent shell variable expansion.

### Examples

**Multi-line expressions**:

```bash
brepl <<'EOF'
(require '[clojure.string :as str])
(str/join \", \" [\"a\" \"b\" \"c\"])
EOF
```

**Code with quotes**:

```bash
brepl <<'EOF'
(println \"String with 'single' and \\\"double\\\" quotes\")
EOF
```

**Reloading and testing**:

```bash
brepl <<'EOF'
(require '[myapp.core] :reload)
(myapp.core/some-function \"test\" 123)
EOF
```

**Complex data structures**:

```bash
brepl <<'EOF'
(def config
  {:database {:host \"localhost\"
              :port 5432
              :name \"mydb\"}
   :api {:key \"secret-key\"
         :endpoint \"https://api.example.com\"}})
(println (:database config))
EOF
```

**Running tests**:

```bash
brepl <<'EOF'
(require '[clojure.test :refer [run-tests]])
(require '[myapp.core-test] :reload)
(run-tests 'myapp.core-test)
EOF
```

## Alternative: Simple Expressions

For very simple expressions, you can use direct positional arguments:

```bash
# Simple expression
brepl '(inc 1)'

# Same with heredoc (consistent approach)
brepl <<'EOF'
(inc 1)
EOF
```

**Why prefer heredoc:** No mental overhead deciding which pattern to use, no risk of quoting issues, easy to extend.

## Loading Files

To load an entire file into the REPL:

```bash
brepl -f src/myapp/core.clj
```

After loading, you can evaluate functions from that namespace using either pattern.

## Fixing Unbalanced Brackets

Use `brepl balance` to fix unbalanced brackets in Clojure files using parmezan:

```bash
# Fix file in place (default)
brepl balance src/myapp/core.clj

# Preview fix to stdout
brepl balance src/myapp/core.clj --dry-run
```

This is useful for recovering files with bracket errors.

## Common Patterns

### Namespace reloading

```bash
brepl <<'EOF'
(require '[myapp.core] :reload-all)
EOF
```

### Documentation lookup

```bash
brepl <<'EOF'
(require '[clojure.repl :refer [doc source]])
(doc map)
(source filter)
EOF
```

### Error inspection

```bash
brepl <<'EOF'
*e
(require '[clojure.repl :refer [pst]])
(pst)
EOF
```

## Critical Rules

1. **Always use heredoc** - Use the heredoc pattern for all brepl evaluations
2. **Quote the delimiter** - Always use `<<'EOF'` not `<<EOF` to prevent shell expansion
3. **No escaping needed** - Inside heredoc, write Clojure code naturally
4. **Multi-step operations** - Combine multiple forms in one heredoc block
5. **Write correct Clojure** - Ensure proper bracket balancing and valid syntax

## Why Always Use Heredoc

**Consistency over optimization.** While simple positional arguments work for basic cases, using heredoc everywhere means:

1. **No decision fatigue** - One pattern for everything
2. **No quoting errors** - Everything between `<<'EOF'` and `EOF` is literal
3. **Easy to extend** - Add more lines without changing syntax
4. **Readable** - Clear where the code starts and ends
5. **Safe** - No shell interpretation of Clojure code

Shell quoting with Clojure is error-prone: Clojure uses both single and double quotes, nested quotes require escaping, and reader macros can confuse the shell. Heredoc eliminates all these issues.

## Resources

brepl documentation: https://github.com/licht1stein/brepl
")
(ns brepl.lib.installer
  "Hook installer for Claude Code integration."
  (:require [babashka.fs :as fs]
            [brepl.lib.skill-content :as skill-content]
            [cheshire.core :as json]
            [clojure.string :as str]))

(defn settings-local-path []
  ".claude/settings.local.json")

(defn read-settings
  "Read existing .claude/settings.local.json or return empty map."
  []
  (let [path (settings-local-path)]
    (if (fs/exists? path)
      (try
        (json/parse-string (slurp path) true)
        (catch Exception e
          (println "Warning: Could not parse existing settings.local.json")
          {}))
      {})))

(defn write-settings
  "Write settings to .claude/settings.local.json."
  [settings]
  (let [path (settings-local-path)]
    ;; Ensure .claude directory exists
    (fs/create-dirs ".claude")
    ;; Write settings file
    (spit path (json/generate-string settings {:pretty true}))))

(defn brepl-hook-config
  "Generate brepl hook configuration for Claude Code."
  [opts]
  (let [debug-flag (when (:debug opts) " --debug")]
     {:PreToolUse [{:matcher "Edit|Write|Bash"
                    :hooks [{:type "command"
                             :command (str "brepl hook validate" debug-flag)
                             :continueOnError false}]}]
      :PostToolUse [{:matcher ""
                     :hooks [{:type "command"
                              :command (str "brepl hook eval" debug-flag)
                              :continueOnError (not (:strict-eval opts))}]}]
     :Stop [{:matcher ""
             :hooks [{:type "command"
                      :command (str "brepl hook stop" debug-flag)}]}]
     :SessionEnd [{:matcher "*"
                   :hooks [{:type "command"
                            :command "brepl hook session-end"}]}]}))

(defn brepl-hook?
  "Check if a hook entry belongs to brepl."
  [hook-entry]
  (some #(str/starts-with? (:command %) "brepl hook")
        (:hooks hook-entry)))

(defn merge-hook-event
  "Merge new brepl entries with existing non-brepl entries for a single event."
  [existing-entries new-entries]
  (let [non-brepl (remove brepl-hook? existing-entries)]
    (into (vec non-brepl) new-entries)))

(defn merge-hooks
  "Merge brepl hooks with existing hooks, preserving non-brepl hooks."
  [existing-hooks new-hooks]
  (reduce-kv
   (fn [acc event-name new-entries]
     (let [existing-entries (get acc event-name [])]
       (assoc acc event-name (merge-hook-event existing-entries new-entries))))
   existing-hooks
   new-hooks))

(defn install-skill
  "Install brepl skill to .claude/skills/brepl/."
  []
  (let [target-dir ".claude/skills/brepl"
        skill-file (str target-dir "/SKILL.md")]
    (fs/create-dirs target-dir)
    (spit skill-file skill-content/skill-md)
    {:success true :message "Skill installed to .claude/skills/brepl"}))

(defn uninstall-skill
  "Remove brepl skill from .claude/skills/brepl/."
  []
  (let [target-dir ".claude/skills/brepl"]
    (if (fs/exists? target-dir)
      (do
        (fs/delete-tree target-dir)
        {:success true :message "Skill removed from .claude/skills/brepl"})
      {:success true :message "Skill not found (already uninstalled)"})))

(def hooks-template
  ";; brepl stop hooks configuration

{:stop
 [;; Example: Run tests via nREPL after Claude stops
  ;; {:type :repl
  ;;  :code (clojure.test/run-tests)
  ;;  :required? true    ; Must pass - Claude retries until success
  ;;  :max-retries 10    ; Give up after 10 attempts (0 = infinite)
  ;;  :timeout 120}

  ;; Example: Run linter via bash
  ;; {:type :bash
  ;;  :command \"clj-kondo --lint src\"
  ;;  :required? false   ; Optional - inform on failure but don't retry
  ;;  :timeout 30}
  ]}

;; Hook fields:
;;   :type        - :repl or :bash (required)
;;   :required?   - if true: must pass, retry on failure (default: false)
;;   :max-retries - max retry attempts, 0 = infinite (default: 10)
;;   :timeout     - seconds before timeout (default: 60)
;;
;; REPL hooks:
;;   :code        - Clojure code as s-expression or string (required)
;;
;; Bash hooks:
;;   :command     - shell command to run (required)
;;   :cwd         - working directory (default: \".\")
;;   :env         - environment variables map (default: {})
")

(defn generate-hooks-template
  "Generate .brepl/hooks.edn template if it doesn't exist."
  []
  (let [brepl-dir ".brepl"
        hooks-file (str brepl-dir "/hooks.edn")]
    (if (fs/exists? hooks-file)
      {:created false :message "hooks.edn already exists"}
      (do
        (fs/create-dirs brepl-dir)
        (spit hooks-file hooks-template)
        {:created true :message "Created .brepl/hooks.edn template"}))))

(defn install-hooks
  "Install brepl hooks to .claude/settings.local.json and brepl skill."
  [opts]
  (let [settings (read-settings)
        existing-hooks (get settings :hooks {})
        new-hooks (brepl-hook-config opts)
        merged-hooks (merge-hooks existing-hooks new-hooks)
        updated-settings (assoc settings :hooks merged-hooks)]
    (write-settings updated-settings)
    (let [skill-result (install-skill)
          template-result (generate-hooks-template)]
      {:success true
       :message (str "Hooks installed successfully"
                     (when (:created template-result)
                       ". Created .brepl/hooks.edn template"))})))

(defn uninstall-hooks
  "Remove brepl hooks from .claude/settings.local.json."
  []
  (let [settings (read-settings)
        updated-settings (dissoc settings :hooks)
        path (settings-local-path)]
    (if (empty? updated-settings)
      ;; If no other settings, remove file
      (when (fs/exists? path)
        (fs/delete path))
      ;; Otherwise just update
      (write-settings updated-settings))
    {:success true :message "Hooks uninstalled successfully"}))

(defn check-status
  "Check hook installation status."
  []
  (let [settings (read-settings)
        has-hooks (contains? settings :hooks)]
    {:installed has-hooks
     :settings-path (settings-local-path)
     :hooks (when has-hooks (:hooks settings))}))
(ns brepl.lib.backup
  "Backup and restore functionality for Claude Code hooks."
  (:require [clojure.java.io :as io])
  (:import [java.nio.file Files Paths]
           [java.nio.file.attribute PosixFilePermissions]))

(defn session-backup-dir
  "Get the backup directory for a session."
  [session-id]
  (io/file (str "/tmp/brepl-hooks-" session-id)))

(defn ensure-session-dir
  "Create session backup directory if it doesn't exist."
  [session-id]
  (let [dir (session-backup-dir session-id)]
    (.mkdirs dir)
    dir))

(defn backup-file-path
  "Get the backup file path for a given file."
  [session-id file-path]
  (let [dir (ensure-session-dir session-id)
        ;; Hash the file path to create a unique backup filename
        hash-code (str (Math/abs (.hashCode file-path)))
        backup-name (str "backup-" hash-code ".clj")]
    (io/file dir backup-name)))

(defn get-file-permissions
  "Get POSIX file permissions from a file."
  [file-path]
  (try
    (let [path (Paths/get file-path (make-array String 0))
          perms (Files/getPosixFilePermissions path nil)]
      perms)
    (catch Exception _
      nil)))

(defn set-file-permissions
  "Set POSIX file permissions on a file."
  [file-path perms]
  (when perms
    (try
      (let [path (Paths/get file-path (make-array String 0))]
        (Files/setPosixFilePermissions path perms))
      (catch Exception _
        nil))))

(defn create-backup
  "Create a backup of a file before it's edited.
   Returns the backup file path, or nil if backup fails."
  [file-path session-id]
  (try
    (if (not (.exists (io/file file-path)))
      ;; File doesn't exist yet, no backup needed
      nil
      ;; File exists, create backup
      (let [backup-path (backup-file-path session-id file-path)
            original-content (slurp file-path)
            perms (get-file-permissions file-path)]
        ;; Write backup
        (spit backup-path original-content)
        ;; Preserve permissions
        (when perms
          (set-file-permissions (str backup-path) perms))
        ;; Store metadata for restore
        (spit (io/file (str backup-path ".meta"))
              (str file-path))
        backup-path))
    (catch Exception e
      ;; Backup failed
      nil)))

(defn restore-backup
  "Restore a file from backup.
   Returns true if restore succeeded, false otherwise."
  [session-id file-path]
  (try
    (let [backup-path (backup-file-path session-id file-path)]
      (if (.exists backup-path)
        (let [backup-content (slurp backup-path)
              perms (get-file-permissions (str backup-path))]
          ;; Restore content
          (spit file-path backup-content)
          ;; Restore permissions
          (when perms
            (set-file-permissions file-path perms))
          true)
        false))
    (catch Exception e
      false)))

(defn cleanup-session
  "Delete all backup files for a session."
  [session-id]
  (let [dir (session-backup-dir session-id)]
    (when (.exists dir)
      (doseq [file (.listFiles dir)]
        (.delete file))
      (.delete dir)
      true)))
(ns borkdude.parmezan
  (:require [clojure.string :as str]
            [edamame.core :as e]))

(defn- split-at-pos [s pos]
  (if (> pos (count s))
    [s nil]
    [(subs s 0 pos) (subs s pos)]))

(defn- replace-char-at-pos [s pos char]
  (str (subs s 0 pos) char (subs s (inc pos))))

(defn parmezan [s]
  (loop [s s]
      (let [[status s]
            (try (e/parse-string-all s {:all true
                                        :features #?(:bb
                                                     ;; wait for new bb release to remove this
                                                     #{:clj :cljs :bb}
                                                     :default identity)
                                        :read-cond :allow
                                        :auto-resolve name
                                        :readers (fn [_tag]
                                                   (fn [val] val))})
                 [::success s]
                 (catch #?(:clj clojure.lang.ExceptionInfo
                           :cljs ExceptionInfo) e
                   (if-let [expected-delimiter (:edamame/expected-delimiter (ex-data e))]
                     ;; Edamame pre https://github.com/borkdude/edamame/issues/136
                     (let [{:keys [row col]} (ex-data e)
                           lines (str/split-lines s)
                           [before-rows after-rows] (split-at (dec row) lines)
                           [row & after-rows] after-rows
                           row (if (zero? (count expected-delimiter))
                                 (replace-char-at-pos row (dec col) "")
                                 (let [[before-cols after-cols] (split-at-pos (or row "") (dec col))
                                       row (str before-cols expected-delimiter after-cols)]
                                   row))
                           new-s (str/join \newline (concat before-rows [row] after-rows))]
                       [::recur new-s])
                     (throw e))))]
        (case status
          ::success s
          ::recur (recur s)))))

(comment
  (parmezan "#js [")
  )
(ns brepl.lib.validator
  "Validates and fixes Clojure code syntax using parmezan."
  (:require [borkdude.parmezan :as parmezan]
            [clojure.java.io :as io]
            [clojure.string :as str]))

(defn auto-fix-brackets
  "Attempt to auto-fix bracket errors using parmezan.
   Returns fixed content if successful, or nil if unable to fix."
  [content]
  (try
    (parmezan/parmezan content)
    (catch Exception e
      nil)))

(defn- has-bb-shebang-from-file?
  "Check if file starts with a Babashka shebang by reading only first line."
  [file-path]
  (try
    (with-open [rdr (io/reader file-path)]
      (when-let [first-line (.readLine rdr)]
        (and (str/starts-with? first-line "#!")
             (str/includes? first-line "bb"))))
    (catch Exception _
      false)))

(defn- has-bb-shebang-from-string?
  "Check if string content starts with a Babashka shebang."
  [content]
  (when content
    (let [first-line (first (str/split-lines content))]
      (and first-line
           (str/starts-with? first-line "#!")
           (str/includes? first-line "bb")))))

(defn clojure-file?
  "Check if file is a Clojure/Babashka source file.
   Checks file extension and optionally checks for shebang.

   With one arg (file-path): checks extension, then reads first line if needed.
   With two args (file-path content): checks extension, then checks content string."
  ([file-path]
   (let [ext (-> file-path
                (str/split #"\.")
                 last
                 str/lower-case)]
     (or (contains? #{"clj" "cljs" "cljc" "cljx" "bb"} ext)
         (has-bb-shebang-from-file? file-path))))
  ([file-path content]
   (let [ext (-> file-path
                (str/split #"\.")
                 last
                 str/lower-case)]
     (or (contains? #{"clj" "cljs" "cljc" "cljx" "bb"} ext)
         (has-bb-shebang-from-string? content)))))

(ns brepl
  (:require [babashka.cli :as cli]
            [clojure.java.io :as io]
            [babashka.fs :as fs]
            [clojure.string :as str]
            [bencode.core :as bencode]
            [clojure.pprint :as pp]
            [clojure.walk :as walk]
            [cheshire.core :as json]
            [brepl.lib.validator :as validator]
            [brepl.lib.backup :as backup]
            [brepl.lib.installer :as installer]
            [brepl.lib.stop-hooks :as stop-hooks]
            [brepl.lib.file-tracker :as file-tracker])
  (:import [java.net Socket]
           [java.io PushbackInputStream]))

(def version "2.6.0")

(def cli-spec
  {:e {:desc "Expression to evaluate (everything after -e is treated as code)"
       :ref "<expr>"}
   :f {:desc "File to load and execute"
       :ref "<file>"}
   :m {:desc "Raw nREPL message (EDN format)"
       :ref "<message>"
       :alias :message}
   :h {:desc "nREPL host"
       :ref "<host>"
       :default "localhost"
       :default-desc "localhost or BREPL_HOST"}
   :p {:desc "nREPL port (required - auto-detects from .nrepl-port or BREPL_PORT)"
       :ref "<port>"}
   :verbose {:desc "Show raw nREPL messages instead of parsed output"
             :coerce :boolean}
   :version {:desc "Show brepl version"
             :coerce :boolean}
   :help {:desc "Show this help message"
          :alias :?
          :coerce :boolean}
   :hook {:desc "Output Claude Code hook-compatible JSON format"
          :coerce :boolean}})

(defn print-help []
  (println "brepl - Bracket-fixing REPL")
  (println)
  (println "USAGE:")
  (println "    brepl [OPTIONS] <expr>")
  (println "    brepl [OPTIONS] -e <expr>")
  (println "    brepl [OPTIONS] <<'EOF' ... EOF")
  (println "    brepl [OPTIONS] -f <file>")
  (println "    brepl [OPTIONS] -m <message>")
  (println "    brepl hooks <subcommand> [args]")
  (println "    brepl skill <subcommand>")
  (println "    brepl balance <file> [--dry-run]")
  (println)
  (println "OPTIONS:")
  (println (cli/format-opts {:spec cli-spec :order [:e :f :m :h :p :verbose :version :help]}))
  (println)
  (println "PORT RESOLUTION:")
  (println "    Port is resolved in the following order:")
  (println "    1. -p <port> command line argument")
  (println "    2. .nrepl-port file:")
  (println "       - For -f: searches from file's directory upward to find project-specific port")
  (println "       - For -e/-m: uses .nrepl-port in current directory")
  (println "    3. BREPL_PORT environment variable")
  (println "    4. Error if none found")
  (println)
  (println "EXAMPLES:")
  (println "    brepl '(+ 1 2 3)'              # Positional argument (implicit -e)")
  (println "    brepl -e '(+ 1 2 3)'           # Explicit -e flag")
  (println "    brepl <<'EOF'                  # Stdin heredoc (implicit -e)")
  (println "      (+ 1 2 3)")
  (println "      EOF")
  (println "    echo '(+ 1 2)' | brepl         # Piped stdin")
  (println "    brepl -f script.clj")
  (println "    brepl -m '{\"op\" \"describe\"}'")
  (println "    brepl -p 7888 '(println \"Hello\")'")
  (println "    BREPL_PORT=7888 brepl '(+ 1 2)'")
  (println "    brepl balance src/core.clj     # Fix unbalanced brackets"))

(defn read-nrepl-port []
  (when (.exists (io/file ".nrepl-port"))
    (-> (slurp ".nrepl-port")
        str/trim
        Integer/parseInt)))

(defn find-nrepl-port-in-parents
  "Search for .nrepl-port file starting from the given directory and walking up to CWD.
  Stops at CWD to avoid searching outside the project.
  Returns the port number from the first .nrepl-port file found, or nil if none found."
  [start-dir]
  (let [cwd (fs/absolutize (fs/cwd))]
    (loop [dir (fs/absolutize start-dir)]
      (when dir
        (let [port-file (fs/file dir ".nrepl-port")]
          (if (fs/exists? port-file)
            (let [port (try
                         (-> (slurp port-file)
                             str/trim
                             Integer/parseInt)
                         (catch Exception e
                           ;; If we can't parse the port file, continue searching
                           nil))]
              (if port
                port
                (recur (fs/parent dir))))
            ;; No port file, continue if we haven't reached CWD yet
            (let [parent (fs/parent dir)]
              (when (and parent (not (= dir cwd)))
                (recur parent)))))))))

(defn get-env-var [var-name]
  (System/getenv var-name))

(defn resolve-host [cli-host]
  (or cli-host (get-env-var "BREPL_HOST") "localhost"))

(defn resolve-port
  "Resolve the nREPL port from various sources.
  Priority: CLI arg > .nrepl-port file > BREPL_PORT env var
  When file-path is provided (for -f option), searches for .nrepl-port
  starting from the file's directory and walking up the tree."
  ([cli-port] (resolve-port cli-port nil))
  ([cli-port file-path]
   (or cli-port
       (if file-path
         ;; For -f option: search from file's directory upward
         (let [parent-dir (fs/parent (fs/absolutize file-path))]
           (when parent-dir
             (find-nrepl-port-in-parents parent-dir)))
         ;; For -e and -m options: use current directory
         (read-nrepl-port))
       (when-let [env-port (get-env-var "BREPL_PORT")]
         (Integer/parseInt env-port)))))

(defn stdin-available?
  "Check if stdin has data available without blocking"
  []
  (pos? (.available System/in)))

(defn read-stdin
  "Read all available input from stdin.
  Returns nil if stdin has no data."
  []
  (when (stdin-available?)
    (try
      (let [input (slurp *in*)]
        (when-not (str/blank? input)
          input))
      (catch Exception _ nil))))

(defn exit-with-help [msg]
  (when msg (println msg) (println))
  (print-help)
  (System/exit 1))

(defn validate-args [opts stdin-available?]
  (when (:help opts) (print-help) (System/exit 0))
  (when (:version opts) (println (str "brepl " version)) (System/exit 0))

  (let [modes (select-keys opts [:e :f :m])
        mode-count (count modes)]
    (cond
      (> mode-count 1) (exit-with-help "Error: Cannot specify multiple options (-e, -f, -m) together")
      ;; Allow zero modes if stdin is available
      (and (zero? mode-count) (not stdin-available?))
      (exit-with-help "Error: Must specify one of -e EXPR, -f FILE, or -m MESSAGE")
      (and (:f modes) (not (.exists (io/file (:f opts)))))
      (do (println "Error: File does not exist:" (:f opts))
          (System/exit 1)))))

;; nREPL client implementation
(defn ->str [x]
  (if (bytes? x)
    (String. x)
    x))

(defn ->str-deep [x]
  (walk/postwalk ->str x))

(defn send-eval-message [host port code opts]
  (let [socket (Socket. host port)
        out (.getOutputStream socket)
        in (PushbackInputStream. (.getInputStream socket))
        msg-id (str (System/currentTimeMillis))
        msg {"op" "eval"
             "code" (str code)
             "id" msg-id}]

    ;; Print client message in verbose mode
    (when (:verbose opts)
      (pp/pprint msg))

    (bencode/write-bencode out msg)
    (.flush out)

    ;; Collect all response messages until we get "done" status
    (loop [responses []]
      (let [response (bencode/read-bencode in)
            _ (when (:verbose opts) (pp/pprint (->str-deep response)))
            status-set (some->> (get response "status") (map ->str) set)]
        (if (contains? status-set "done")
          (do
            (.close socket)
            (if (:verbose opts)
              responses ; Return empty since we already printed
              (conj responses response)))
          (recur (if (:verbose opts)
                   responses ; Don't accumulate in verbose mode
                   (conj responses response))))))))

(defn process-eval-responses [responses]
  (reduce (fn [acc resp]
            (cond-> acc
              (get resp "out")    (update :out conj (->str (get resp "out")))
              (get resp "err")    (update :err conj (->str (get resp "err")))
              (get resp "value")  (update :values conj (->str (get resp "value")))
              (get resp "ex")     (assoc :ex (->str (get resp "ex")))
              (get resp "status") (update :status into (->str (flatten [(get resp "status")])))))
          {:out [] :err [] :values [] :ex nil :status []}
          responses))

(defn format-hook-response [processed has-error?]
  (if-not has-error?
    {:continue true :suppressOutput true}
    (let [parts (cond-> []
                  (:ex processed)  (conj (:ex processed))
                  (seq (:err processed)) (into (:err processed))
                  (seq (:out processed)) (into (:out processed)))
          msg (if (seq parts)
                (str/join " | " parts)
                "Evaluation error occurred")]
      {:continue true
       :suppressOutput true
       :decision "block"
       :stopReason msg
       :reason (str "Code evaluation failed:\n" (str/join "\n" parts))})))

(defn eval-expression [host port code opts]
  (try
    (let [responses (send-eval-message host port code opts)]

      ;; Process responses to check for errors even in verbose mode
      (let [processed (process-eval-responses responses)
            has-error? (or (:ex processed)
                           (some #{"eval-error"} (flatten (:status processed))))]

        ;; If hook mode, return processed data
        (if (:hook opts)
          {:processed processed
           :has-error? has-error?}

          ;; Otherwise handle output normally
          (do
            ;; If verbose mode, responses were already printed
            (if (:verbose opts)
              has-error? ; Just return error status

              ;; Otherwise print output normally
              (do
                ;; Print stdout output
                (doseq [out (:out processed)]
                  (print out))

                ;; Print stderr output to stderr
                (doseq [err (:err processed)]
                  (binding [*out* *err*]
                    (print err)
                    (flush)))

                ;; Print evaluation results
                (doseq [val (:values processed)]
                  (println val))

                ;; Handle exceptions
                (when (:ex processed)
                  (binding [*out* *err*]
                    (println "Exception:" (:ex processed))))

                ;; Handle empty response
                (when (and (empty? (:values processed))
                           (empty? (:out processed))
                           (empty? (:err processed))
                           (not (:ex processed)))
                  (when (some #{"eval-error"} (flatten (:status processed)))
                    (binding [*out* *err*]
                      (println "Evaluation error occurred"))))

                ;; Return error status
                has-error?))))))

    (catch Exception e
      (if (:hook opts)
        {:processed {:ex (str "Connection error: " (.getMessage e))}
         :has-error? true}
        (do
          (println "Error connecting to nREPL server at" (str host ":" port))
          (println (.getMessage e))
          (System/exit 1))))))

(defn eval-file [host port file-path opts]
  (let [code (str "(load-file \"" file-path "\")")]
    (eval-expression host port code opts)))

(defn send-raw-message [host port message-str opts]
  (try
    (let [socket (Socket. host port)
          out (.getOutputStream socket)
          in (PushbackInputStream. (.getInputStream socket))
          ;; Parse the EDN message and add an ID if not present
          msg (read-string message-str)
          msg-with-id (if (get msg "id")
                        msg
                        (assoc msg "id" (str (System/currentTimeMillis))))]

      ;; Print client message in verbose mode
      (when (:verbose opts)
        (pp/pprint msg-with-id))

      (bencode/write-bencode out msg-with-id)
      (.flush out)

      ;; Collect all response messages until we get "done" status or no status
      (loop [responses []
             timeout-count 0]
        (let [response (bencode/read-bencode in)
              _ (when (:verbose opts) (pp/pprint (->str-deep response)))
              status-set (some->> (get response "status") (map ->str) set)]
          (cond
            (contains? status-set "done")
            (do
              (.close socket)
              (if (:verbose opts)
                responses ; Return empty since we already printed
                (conj responses response)))

            ;; For operations that don't return "done", stop after reasonable response count
            (> timeout-count 10)
            (do
              (.close socket)
              responses)

            ;; Otherwise keep reading
            :else
            (recur (if (:verbose opts)
                     responses ; Don't accumulate in verbose mode
                     (conj responses response))
                   (inc timeout-count))))))

    (catch Exception e
      (println "Error sending message to nREPL server at" (str host ":" port))
      (println (.getMessage e))
      (System/exit 1))))

(defn process-raw-message [host port message-str opts]
  (let [responses (send-raw-message host port message-str opts)]
    ;; In verbose mode, everything was already printed
    (when-not (:verbose opts)
      (doseq [resp responses]
        (pp/pprint (->str-deep resp))))))

(defn -main [& args]
  (let [parsed (cli/parse-opts args {:spec cli-spec :args->opts [:e]})
        ;; Check if stdin is available (non-blocking)
        has-stdin? (and (not (:f parsed))
                        (not (:m parsed))
                        (not (:e parsed))
                        (stdin-available?))
        host (resolve-host (:h parsed))
        port (resolve-port (:p parsed) (:f parsed))]

    (validate-args parsed has-stdin?)

    ;; After validation passes, try reading stdin if we have no input
    (let [should-try-stdin? (and (not (:f parsed))
                                 (not (:m parsed))
                                 (not (:e parsed)))
          stdin-input (when should-try-stdin? (read-stdin))
          opts (if stdin-input
                 (assoc parsed :e stdin-input)
                 parsed)]

      (when-not port
        (println "Error: No port specified, no .nrepl-port file found, and BREPL_PORT not set")
        (System/exit 1))

      (let [result (cond
                     (:e opts) (eval-expression host port (:e opts) opts)
                     (:f opts) (eval-file host port (:f opts) opts)
                   (:m opts) (do (process-raw-message host port (:m opts) opts)
                                 false))] ; raw messages don't track errors

        ;; Handle hook mode
        (if (:hook opts)
          (let [{:keys [processed has-error?]} result
                hook-response (format-hook-response processed has-error?)]
            (println (json/generate-string hook-response))
            (System/exit (if has-error? 2 0)))

          ;; Regular mode - for backward compatibility, use exit code 2 for eval errors
          (when result
            (System/exit 2)))))))

(defn debug-log [msg]
  (spit "/tmp/brepl-hook-debug.log"
        (str (java.time.LocalDateTime/now) " - " msg "\n")
        :append true))

(defn save-hook-debug-json [tool-name hook-data]
  (try
    (let [timestamp (str (System/currentTimeMillis))
          debug-dir "./tmp/hooks-requests"
          filename (str debug-dir "/" tool-name "-" timestamp ".json")]
      (fs/create-dirs debug-dir)
      (spit filename (json/generate-string hook-data {:pretty true}))
      (debug-log (str "Saved debug JSON to: " filename)))
    (catch Exception e
      (debug-log (str "ERROR saving debug JSON: " (.getMessage e))))))

(defn json-exit [response exit-code]
  (println (json/generate-string response))
  (System/exit exit-code))

(defn block-hook
  ([reason] (block-hook "PreToolUse" reason))
  ([event-name reason]
   (json-exit {:hookSpecificOutput
               {:hookEventName event-name
                :permissionDecision "deny"
                :permissionDecisionReason reason}} 1)))

(defn allow-hook
  ([] (json-exit {:hookSpecificOutput
                  {:hookEventName "PreToolUse"
                   :permissionDecision "allow"}} 0))
  ([event-name] (json-exit {:hookSpecificOutput
                             {:hookEventName event-name
                              :permissionDecision "allow"}} 0))
  ([tool-name tool-input fixed-content]
   (let [updated-input (case tool-name
                         "Edit" (assoc tool-input :new_string fixed-content)
                         "Write" (assoc tool-input :content fixed-content)
                         tool-input)]
     (json-exit {:hookSpecificOutput
                 {:hookEventName "PreToolUse"
                  :permissionDecision "allow"
                  :permissionDecisionReason "Auto-fixed bracket errors"
                  :updatedInput updated-input}} 0))))

;; Hook subcommand handlers
(defn get-file-path-from-stdin []
  (try
    (let [file-path (-> (json/parse-stream *in* true)
                        :tool_input
                        :file_path)]
      (debug-log (str "eval hook called for: " file-path))
      file-path)
    (catch Exception e
      (debug-log (str "ERROR parsing stdin: " (.getMessage e)))
      nil)))


(defn parse-hook-input
  "Parse raw hook input from stdin. Returns the full hook data map."
  [args]
  (try
    (let [debug-mode? (some #(= "--debug" %) args)
          hook-data (if debug-mode?
                      (let [raw-input (slurp *in*)]
                        (json/parse-string raw-input true))
                      (json/parse-stream *in* true))]
      (when debug-mode?
        (save-hook-debug-json (:tool_name hook-data) hook-data))
      hook-data)
    (catch Exception e
      (debug-log (str "ERROR parsing stdin: " (.getMessage e)))
      nil)))
(defn get-hook-input [args]
  (if (>= (count args) 2)
    [(first args) (second args) nil nil]
    (try
      (let [debug-mode? (some #(= "--debug" %) args)
            ;; Read stdin as string if debug mode, otherwise use stream
            hook-data (if debug-mode?
                       (let [raw-input (slurp *in*)]
                         (json/parse-string raw-input true))
                       (json/parse-stream *in* true))
            {:keys [tool_name tool_input]} hook-data
            {:keys [file_path content old_string new_string]} tool_input]

        ;; Save debug JSON if debug mode
        (when debug-mode?
          (save-hook-debug-json tool_name hook-data))

        (debug-log (str "Hook called - Tool: " tool_name " File: " file_path))
        (case tool_name
          "Write"  [file_path content tool_name tool_input]
          "Edit"   [file_path new_string tool_name tool_input]
          [nil nil nil nil]))
      (catch Exception e
        (debug-log (str "ERROR parsing stdin: " (.getMessage e)))
        [nil nil nil nil]))))

(defn apply-edit
  "Simulate Edit tool: replace first occurrence of old_string with new_string in file content."
  [file-content old-string new-string]
  (when-let [idx (str/index-of file-content old-string)]
    (str (subs file-content 0 idx)
         new-string
         (subs file-content (+ idx (count old-string))))))

(defn compute-end-delta
  "Compare two strings from the end, return chars removed and added.
   Returns [removed-suffix added-suffix] or nil if changes aren't just at end."
  [original fixed]
  (let [orig-len (count original)
        fixed-len (count fixed)
        ;; Find common prefix length
        common-prefix (loop [i 0]
                        (if (and (< i orig-len)
                                 (< i fixed-len)
                                 (= (nth original i) (nth fixed i)))
                          (recur (inc i))
                          i))]
    ;; Everything after common prefix is the delta
    [(subs original common-prefix)
     (subs fixed common-prefix)]))

(defn adjust-new-string-for-fix
  "Adjust new_string based on what parmezan changed at the end of the file."
  [new-string result-file fixed-file]
  (let [[removed added] (compute-end-delta result-file fixed-file)]
    (cond
      ;; Parmezan added closing brackets at end
      (and (empty? removed) (seq added))
      (str new-string added)

      ;; Parmezan removed extra brackets from end
      (and (seq removed) (empty? added)
           (str/ends-with? new-string removed))
      (subs new-string 0 (- (count new-string) (count removed)))

      ;; Complex change - can't adjust simply
      :else nil)))

(defn emacs-edit-command?
  "Check if a Bash command is an emacs editing command (el, ew, ed, es, ei, etc.)"
  [command]
  (when command
    (boolean (re-find #"^(el|ew|ed|es|ei|eu|esr|ess|esw|esk|est)\s" command))))

(defn handle-validate [args]
  (let [hook-data (parse-hook-input args)
        session-id (:session_id hook-data)
        tool-name (:tool_name hook-data)
        tool-input (:tool_input hook-data)]

    ;; Always take a snapshot for file change detection
    (when session-id
      (file-tracker/snapshot! session-id))

    ;; For non-Edit/Write/Bash tools, just allow
    (when-not (#{"Edit" "Write" "Bash"} tool-name)
      (allow-hook "PreToolUse"))

    ;; For Bash: only validate if it looks like an emacs edit command
    (when (= "Bash" tool-name)
      (let [command (:command tool-input)]
        (when-not (emacs-edit-command? command)
          (allow-hook "PreToolUse"))
        ;; For emacs commands, allow - emacs handles bracket fixing
        (allow-hook "PreToolUse")))

    ;; For Edit/Write: do bracket validation
    (let [{:keys [file_path content old_string new_string]} tool-input
          file-path file_path]

      ;; Skip if no file path or not a Clojure file
      (when (or (nil? file-path) (nil? (or content new_string)))
        (allow-hook "PreToolUse"))

      (when-not (validator/clojure-file? file-path (or content new_string ""))
        (allow-hook "PreToolUse"))

      ;; Compute what the file will look like after this operation
      (let [file-exists? (.exists (io/file file-path))
            current-file (when file-exists? (slurp file-path))
            result-file (case tool-name
                          "Write" content
                          "Edit" (if (and current-file old_string new_string)
                                   (apply-edit current-file old_string new_string)
                                   content)
                          content)]

        (when (nil? result-file)
          (block-hook "PreToolUse" "Could not simulate edit - old_string not found in file"))

        ;; Try to validate/fix brackets with parmezan
        (if-let [fixed (validator/auto-fix-brackets result-file)]
          (do
            ;; Create backup if in Claude Code session
            (when session-id
              (backup/create-backup file-path session-id))

            (if (= fixed result-file)
              (allow-hook "PreToolUse")
              ;; Needs fixing
              (case tool-name
                "Write"
                (allow-hook tool-name tool-input fixed)

                "Edit"
                (if-let [adjusted (adjust-new-string-for-fix new_string result-file fixed)]
                  (allow-hook tool-name tool-input adjusted)
                  (allow-hook "PreToolUse"))

                (allow-hook "PreToolUse"))))
          ;; If parmezan couldn't fix it at all, block
          (block-hook "PreToolUse" (str "Syntax error in " file-path ": unable to auto-fix delimiter errors")))))))

(defn diff-lines
  "Compare original and fixed content, return info about changed lines."
  [original fixed]
  (let [orig-lines (str/split-lines original)
        fixed-lines (str/split-lines fixed)
        orig-count (count orig-lines)
        fixed-count (count fixed-lines)
        max-lines (max orig-count fixed-count)]
    (loop [i 0
           changes []]
      (if (>= i max-lines)
        changes
        (let [orig-line (get orig-lines i)
              fixed-line (get fixed-lines i)]
          (recur (inc i)
                 (cond
                   ;; Line added
                   (nil? orig-line)
                   (conj changes {:line (inc i) :type :added :content fixed-line})
                   ;; Line removed
                   (nil? fixed-line)
                   (conj changes {:line (inc i) :type :removed :content orig-line})
                   ;; Line changed
                   (not= orig-line fixed-line)
                   (conj changes {:line (inc i) :type :changed :from orig-line :to fixed-line})
                   ;; No change
                   :else changes)))))))

(defn format-balance-report
  "Format balance changes for Claude to understand."
  [file-path changes]
  (let [header (str "Auto-fixed brackets in " file-path ":")
        details (for [{:keys [line type content from to]} changes]
                  (case type
                    :added (str "  Line " line ": added \"" content "\"")
                    :removed (str "  Line " line ": removed \"" content "\"")
                    :changed (str "  Line " line ": \"" from "\"  \"" to "\"")))]
    (str/join "\n" (cons header details))))

(defn balance-file!
  "Run balance on file, writing fixes in-place.
   Returns nil if no fix needed, or a report string if fixes were made."
  [file-path]
  (when (validator/clojure-file? file-path)
    (let [content (slurp file-path)
          fixed (validator/auto-fix-brackets content)]
      (when (and fixed (not= fixed content))
        (let [changes (diff-lines content fixed)
              report (format-balance-report file-path changes)]
          (debug-log report)
          (spit file-path fixed)
          report)))))

(defn handle-eval [args]
  (let [hook-data (parse-hook-input args)
        session-id (:session_id hook-data)]

    ;; No session = no tracking, just allow
    (when-not session-id
      (allow-hook "PostToolUse"))

    ;; Detect changed files
    (let [changed-files (file-tracker/detect-changes session-id)]

      ;; No changes detected
      (when (empty? changed-files)
        (allow-hook "PostToolUse"))

      ;; Balance and reload each changed file
      (let [port (resolve-port nil nil)
            host (resolve-host nil)
            results (for [file-path changed-files
                          :when (and (validator/clojure-file? file-path)
                                     (.exists (io/file file-path)))]
                      (let [balance-report (balance-file! file-path)
                            eval-result (when port
                                          (eval-file host port file-path {:hook true}))
                            eval-error (when (:has-error? eval-result)
                                         (get-in eval-result [:processed :ex] "Unknown error"))]
                        {:file file-path
                         :balanced balance-report
                         :error eval-error}))
            messages (->> results
                          (mapcat (fn [{:keys [file balanced error]}]
                                    (cond-> []
                                      balanced (conj (str "Fixed brackets in " file))
                                      error (conj (str "Error in " file ": " error)))))
                          (remove nil?))]

        ;; Update snapshot for next comparison
        (file-tracker/snapshot! session-id)

        (if (seq messages)
          (json-exit {:hookSpecificOutput
                      {:hookEventName "PostToolUse"
                       :permissionDecision "allow"
                       :permissionDecisionReason (str/join "\n" messages)}} 0)
          (allow-hook "PostToolUse"))))))

(defn handle-install [args]
  (let [opts (cli/parse-opts args {:spec {:strict-eval {:coerce :boolean}
                                           :debug {:coerce :boolean}}})
        status (installer/check-status)]
    (installer/install-hooks opts)
    (println "Installing Claude Code hooks...")
    (when (:debug opts)
      (println "Debug mode enabled - hook JSON will be saved to ./tmp/hooks-requests/"))
    (println "Hooks installed successfully.")
    (println)
    (when (:installed status)
      (println "Settings file:" (:settings-path status)))
    (System/exit 0)))

(defn handle-uninstall [_args]
  (installer/uninstall-hooks)
  (println "Removing Claude Code hooks...")
  (println "Hooks uninstalled successfully.")
  (System/exit 0))

(defn handle-session-end [_args]
  (let [input (try
                (json/parse-stream *in* true)
                (catch Exception e
                  (binding [*out* *err*]
                    (println "Error parsing SessionEnd event JSON:" (.getMessage e)))
                  (System/exit 1)))
        session-id (or (:session_id input) "unknown")]
    (backup/cleanup-session session-id)
    ;; Also cleanup stop hook state
    (stop-hooks/cleanup-state session-id)
    ;; Cleanup file tracker state
    (file-tracker/cleanup-state session-id)
    (System/exit 0)))

(defn handle-stop [_args]
  ;; Initialize stop-hooks dynamic vars for REPL hook execution
  (alter-var-root #'stop-hooks/*nrepl-eval-fn* (constantly eval-expression))
  (alter-var-root #'stop-hooks/*resolve-port-fn* (constantly resolve-port))
  (alter-var-root #'stop-hooks/*resolve-host-fn* (constantly resolve-host))

  ;; Parse stdin JSON to get session_id
  (let [input (try
                (json/parse-stream *in* true)
                (catch Exception e
                  (binding [*out* *err*]
                    (println "Error parsing Stop event JSON:" (.getMessage e)))
                  (System/exit 1)))
        session-id (or (:session_id input) "unknown")]

    ;; Load and validate hooks config
    (let [config (stop-hooks/load-hooks)]
      (cond
        ;; No config file - success, no hooks to run
        (nil? config)
        (System/exit 0)

        ;; Parse error in config
        (:error config)
        (do
          (binding [*out* *err*]
            (println "Error parsing .brepl/hooks.edn:" (:error config)))
          (System/exit 1))

        ;; Validate config
        :else
        (let [validation (stop-hooks/validate-hooks config)]
          (if-not (:valid? validation)
            (do
              (binding [*out* *err*]
                (println "Invalid .brepl/hooks.edn:")
                (println (:errors validation)))
              (System/exit 1))

            ;; Run hooks
            (let [result (stop-hooks/run-stop-hooks session-id config)]
              (when (pos? (:exit-code result))
                (binding [*out* *err*]
                  (println (:message result))))
              (System/exit (:exit-code result)))))))))

(defn handle-skill-install [_args]
  (let [result (installer/install-skill)]
    (if (:success result)
      (do (println "Installing brepl skill...")
          (println (:message result))
          (System/exit 0))
      (do (println "Error:" (:message result))
          (System/exit 1)))))

(defn handle-skill-uninstall [_args]
  (let [result (installer/uninstall-skill)]
    (println "Removing brepl skill...")
    (println (:message result))
    (System/exit 0)))

(defn show-hook-help [subcommand]
  (println "brepl hooks - Claude Code integration commands")
  (println)
  (println "USAGE:")
  (println "    brepl hooks validate [--debug] <file> <content>")
  (println "    brepl hooks eval [--debug] <file>")
  (println "    brepl hooks stop")
  (println "    brepl hooks install [--strict-eval] [--debug]")
  (println "    brepl hooks uninstall")
  (println "    brepl hooks session-end")
  (println)
  (println "SUBCOMMANDS:")
  (println "    validate       Validate Clojure file syntax before edit")
  (println "    eval           Evaluate file and check for runtime errors")
  (println "    stop           Run stop hooks from .brepl/hooks.edn")
  (println "    install        Install hooks in .claude/settings.local.json")
  (println "    uninstall      Remove hooks from .claude/settings.local.json")
  (println "    session-end    Clean up session backup files (reads JSON from stdin)")
  (println)
  (println "FLAGS:")
  (println "    --debug        Save hook JSON input to ./tmp/hooks-requests/")
  (println "    --strict-eval  Exit with error on eval failures (install only)")
  (System/exit (if (and subcommand
                        (not (contains? #{"validate" "eval" "stop" "install" "uninstall" "session-end"} subcommand)))
                 1 0)))

(defn show-balance-help []
  (println "brepl balance - Fix unbalanced brackets in Clojure files")
  (println)
  (println "USAGE:")
  (println "    brepl balance <file>")
  (println "    brepl balance <file> --dry-run")
  (println)
  (println "OPTIONS:")
  (println "    --dry-run      Print fixed content to stdout instead of overwriting")
  (println)
  (println "EXAMPLES:")
  (println "    brepl balance src/core.clj             # Fix file in place")
  (println "    brepl balance src/core.clj --dry-run   # Preview fix to stdout")
  (System/exit 0))

(defn handle-balance [args]
  (let [help? (some #(contains? #{"-h" "--help" "-?"} %) args)
        dry-run? (some #(= "--dry-run" %) args)
        file-args (remove #(contains? #{"-h" "--help" "-?" "--dry-run"} %) args)
        file-path (first file-args)]
    (cond
      (or help? (nil? file-path))
      (show-balance-help)

      (not (.exists (io/file file-path)))
      (do (binding [*out* *err*]
            (println "Error: File not found:" file-path))
          (System/exit 1))

      :else
      (let [content (slurp file-path)
            fixed (validator/auto-fix-brackets content)]
        (if fixed
          (if dry-run?
            (do (print fixed)
                (flush)
                (System/exit 0))
            (do (spit file-path fixed)
                (println "Fixed:" file-path)
                (System/exit 0)))
          (do (binding [*out* *err*]
                (println "Error: Unable to fix" file-path))
              (System/exit 1)))))))

(defn -main-balance
  "Handle brepl balance command"
  [args]
  (handle-balance args))

(defn show-skill-help [subcommand]
  (println "brepl skill - Claude Code skill management")
  (println)
  (println "USAGE:")
  (println "    brepl skill install")
  (println "    brepl skill uninstall")
  (println)
  (println "SUBCOMMANDS:")
  (println "    install        Install brepl skill to .claude/skills/brepl")
  (println "    uninstall      Remove brepl skill from .claude/skills/brepl")
  (System/exit (if (and subcommand
                        (not (contains? #{"install" "uninstall"} subcommand)))
                 1 0)))

(defn handle-skill-subcommand [subcommand args]
  (case subcommand
    "install"   (handle-skill-install args)
    "uninstall" (handle-skill-uninstall args)
    (show-skill-help subcommand)))

(defn handle-hook-subcommand [subcommand args]
  (case subcommand
    "validate"    (handle-validate args)
    "eval"        (handle-eval args)
    "stop"        (handle-stop args)
    "install"     (handle-install args)
    "uninstall"   (handle-uninstall args)
    "session-end" (handle-session-end args)
    (show-hook-help subcommand)))

(defn -main-hook
  "Handle brepl hook subcommands"
  [args]
  (if (empty? args)
    (handle-hook-subcommand nil nil)
    (let [subcommand (first args)
          remaining-args (rest args)]
      (handle-hook-subcommand subcommand remaining-args))))

(defn -main-skill
  "Handle brepl skill subcommands"
  [args]
  (if (empty? args)
    (handle-skill-subcommand nil nil)
    (let [subcommand (first args)
          remaining-args (rest args)]
      (handle-skill-subcommand subcommand remaining-args))))


(when (= *file* (System/getProperty "babashka.file"))
  (cond
    (and (> (count *command-line-args*) 0)
         (#{"hook" "hooks"} (first *command-line-args*)))
    (-main-hook (rest *command-line-args*))

    (and (> (count *command-line-args*) 0)
         (= "skill" (first *command-line-args*)))
    (-main-skill (rest *command-line-args*))

    (and (> (count *command-line-args*) 0)
         (= "balance" (first *command-line-args*)))
    (-main-balance (rest *command-line-args*))

    :else
    (apply -main *command-line-args*)))
