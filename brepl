#!/usr/bin/env bb
(ns brepl
  (:require [babashka.cli :as cli]
            [clojure.java.io :as io]
            [babashka.fs :as fs]
            [clojure.string :as str]
            [bencode.core :as bencode]
            [clojure.pprint :as pp]
            [clojure.walk :as walk]
            [cheshire.core :as json])
  (:import [java.net Socket]
           [java.io PushbackInputStream]))

(def version "2.0.3")

;; Load lib files and require namespaces
(let [script-dir (some-> (System/getProperty "babashka.file")
                         io/file
                         .getParentFile
                         .getAbsolutePath)]
  (doseq [lib ["hook_utils" "validator" "backup" "installer"]]
    (load-file (str script-dir "/lib/" lib ".clj"))))

(require '[brepl.lib.validator :as validator]
         '[brepl.lib.backup :as backup]
         '[brepl.lib.installer :as installer])

(def cli-spec
  {:e {:desc "Expression to evaluate (everything after -e is treated as code)"
       :ref "<expr>"}
   :f {:desc "File to load and execute"
       :ref "<file>"}
   :m {:desc "Raw nREPL message (EDN format)"
       :ref "<message>"
       :alias :message}
   :h {:desc "nREPL host"
       :ref "<host>"
       :default "localhost"
       :default-desc "localhost or BREPL_HOST"}
   :p {:desc "nREPL port (required - auto-detects from .nrepl-port or BREPL_PORT)"
       :ref "<port>"}
   :verbose {:desc "Show raw nREPL messages instead of parsed output"}
   :version {:desc "Show brepl version"}
   :help {:desc "Show this help message"
          :alias :?}
   :hook {:desc "Output Claude Code hook-compatible JSON format"}})

(defn parinfer-available? []
  (some? (fs/which "parinfer-rust")))

(defn print-help []
  (println "brepl - Bracket-fixing REPL")
  (println)
  (println "USAGE:")
  (println "    brepl [OPTIONS] -e <expr>")
  (println "    brepl [OPTIONS] -f <file>")
  (println "    brepl [OPTIONS] -m <message>")
  (println "    brepl hook <subcommand> [args]")
  (println)
  (println "OPTIONS:")
  (println (cli/format-opts {:spec cli-spec :order [:e :f :m :h :p :verbose :version :help]}))
  (println)
  (println "PORT RESOLUTION:")
  (println "    Port is resolved in the following order:")
  (println "    1. -p <port> command line argument")
  (println "    2. .nrepl-port file:")
  (println "       - For -f: searches from file's directory upward to find project-specific port")
  (println "       - For -e/-m: uses .nrepl-port in current directory")
  (println "    3. BREPL_PORT environment variable")
  (println "    4. Error if none found")
  (println)
  (println "FEATURES:")
  (if (parinfer-available?)
    (println "    parinfer-rust: \u001b[32mavailable (auto-fix mode)\u001b[0m")
    (println "    parinfer-rust: not found (prevention mode)"))
  (println)
  (println "EXAMPLES:")
  (println "    brepl -e '(+ 1 2 3)'")
  (println "    brepl -f script.clj")
  (println "    brepl -m '{\"op\" \"describe\"}'")
  (println "    brepl -p 7888 -e '(println \"Hello\")'")
  (println "    BREPL_PORT=7888 brepl -e '(+ 1 2)'"))

(defn read-nrepl-port []
  (when (.exists (io/file ".nrepl-port"))
    (-> (slurp ".nrepl-port")
        str/trim
        Integer/parseInt)))

(defn find-nrepl-port-in-parents
  "Search for .nrepl-port file starting from the given directory and walking up to CWD.
  Stops at CWD to avoid searching outside the project.
  Returns the port number from the first .nrepl-port file found, or nil if none found."
  [start-dir]
  (let [cwd (fs/absolutize (fs/cwd))]
    (loop [dir (fs/absolutize start-dir)]
      (when dir
        (let [port-file (fs/file dir ".nrepl-port")]
          (if (fs/exists? port-file)
            (let [port (try
                         (-> (slurp port-file)
                             str/trim
                             Integer/parseInt)
                         (catch Exception e
                           ;; If we can't parse the port file, continue searching
                           nil))]
              (if port
                port
                (recur (fs/parent dir))))
            ;; No port file, continue if we haven't reached CWD yet
            (let [parent (fs/parent dir)]
              (when (and parent (not (= dir cwd)))
                (recur parent)))))))))

(defn get-env-var [var-name]
  (System/getenv var-name))

(defn resolve-host [cli-host]
  (or cli-host (get-env-var "BREPL_HOST") "localhost"))

(defn resolve-port
  "Resolve the nREPL port from various sources.
  Priority: CLI arg > .nrepl-port file > BREPL_PORT env var
  When file-path is provided (for -f option), searches for .nrepl-port
  starting from the file's directory and walking up the tree."
  ([cli-port] (resolve-port cli-port nil))
  ([cli-port file-path]
   (or cli-port
       (if file-path
         ;; For -f option: search from file's directory upward
         (let [parent-dir (fs/parent (fs/absolutize file-path))]
           (when parent-dir
             (find-nrepl-port-in-parents parent-dir)))
         ;; For -e and -m options: use current directory
         (read-nrepl-port))
       (when-let [env-port (get-env-var "BREPL_PORT")]
         (Integer/parseInt env-port)))))

(defn exit-with-help [msg]
  (when msg (println msg) (println))
  (print-help)
  (System/exit 1))

(defn validate-args [opts]
  (when (:help opts) (print-help) (System/exit 0))
  (when (:version opts) (println (str "brepl " version)) (System/exit 0))

  (let [modes (select-keys opts [:e :f :m])
        mode-count (count modes)]
    (cond
      (> mode-count 1) (exit-with-help "Error: Cannot specify multiple options (-e, -f, -m) together")
      (zero? mode-count) (exit-with-help "Error: Must specify one of -e EXPR, -f FILE, or -m MESSAGE")
      (and (:f modes) (not (.exists (io/file (:f opts)))))
      (do (println "Error: File does not exist:" (:f opts))
          (System/exit 1)))))

;; nREPL client implementation
(defn ->str [x]
  (if (bytes? x)
    (String. x)
    x))

(defn ->str-deep [x]
  (walk/postwalk ->str x))

(defn send-eval-message [host port code opts]
  (let [socket (Socket. host port)
        out (.getOutputStream socket)
        in (PushbackInputStream. (.getInputStream socket))
        msg-id (str (System/currentTimeMillis))
        msg {"op" "eval"
             "code" (str code)
             "id" msg-id}]

    ;; Print client message in verbose mode
    (when (:verbose opts)
      (pp/pprint msg))

    (bencode/write-bencode out msg)
    (.flush out)

    ;; Collect all response messages until we get "done" status
    (loop [responses []]
      (let [response (bencode/read-bencode in)
            _ (when (:verbose opts) (pp/pprint (->str-deep response)))
            status-set (some->> (get response "status") (map ->str) set)]
        (if (contains? status-set "done")
          (do
            (.close socket)
            (if (:verbose opts)
              responses ; Return empty since we already printed
              (conj responses response)))
          (recur (if (:verbose opts)
                   responses ; Don't accumulate in verbose mode
                   (conj responses response))))))))

(defn process-eval-responses [responses]
  (reduce (fn [acc resp]
            (cond-> acc
              (get resp "out")    (update :out conj (->str (get resp "out")))
              (get resp "err")    (update :err conj (->str (get resp "err")))
              (get resp "value")  (update :values conj (->str (get resp "value")))
              (get resp "ex")     (assoc :ex (->str (get resp "ex")))
              (get resp "status") (update :status into (->str (flatten [(get resp "status")])))))
          {:out [] :err [] :values [] :ex nil :status []}
          responses))

(defn format-hook-response [processed has-error?]
  (if-not has-error?
    {:continue true :suppressOutput true}
    (let [parts (cond-> []
                  (:ex processed)  (conj (:ex processed))
                  (seq (:err processed)) (into (:err processed))
                  (seq (:out processed)) (into (:out processed)))
          msg (if (seq parts)
                (str/join " | " parts)
                "Evaluation error occurred")]
      {:continue true
       :suppressOutput true
       :decision "block"
       :stopReason msg
       :reason (str "Code evaluation failed:\n" (str/join "\n" parts))})))

(defn eval-expression [host port code opts]
  (try
    (let [responses (send-eval-message host port code opts)]

      ;; Process responses to check for errors even in verbose mode
      (let [processed (process-eval-responses responses)
            has-error? (or (:ex processed)
                           (some #{"eval-error"} (flatten (:status processed))))]

        ;; If hook mode, return processed data
        (if (:hook opts)
          {:processed processed
           :has-error? has-error?}

          ;; Otherwise handle output normally
          (do
            ;; If verbose mode, responses were already printed
            (if (:verbose opts)
              has-error? ; Just return error status

              ;; Otherwise print output normally
              (do
                ;; Print stdout output
                (doseq [out (:out processed)]
                  (print out))

                ;; Print stderr output to stderr
                (doseq [err (:err processed)]
                  (binding [*out* *err*]
                    (print err)
                    (flush)))

                ;; Print evaluation results
                (doseq [val (:values processed)]
                  (println val))

                ;; Handle exceptions
                (when (:ex processed)
                  (binding [*out* *err*]
                    (println "Exception:" (:ex processed))))

                ;; Handle empty response
                (when (and (empty? (:values processed))
                           (empty? (:out processed))
                           (empty? (:err processed))
                           (not (:ex processed)))
                  (when (some #{"eval-error"} (flatten (:status processed)))
                    (binding [*out* *err*]
                      (println "Evaluation error occurred"))))

                ;; Return error status
                has-error?))))))

    (catch Exception e
      (if (:hook opts)
        {:processed {:ex (str "Connection error: " (.getMessage e))}
         :has-error? true}
        (do
          (println "Error connecting to nREPL server at" (str host ":" port))
          (println (.getMessage e))
          (System/exit 1))))))

(defn eval-file [host port file-path opts]
  (let [code (str "(load-file \"" file-path "\")")]
    (eval-expression host port code opts)))

(defn send-raw-message [host port message-str opts]
  (try
    (let [socket (Socket. host port)
          out (.getOutputStream socket)
          in (PushbackInputStream. (.getInputStream socket))
          ;; Parse the EDN message and add an ID if not present
          msg (read-string message-str)
          msg-with-id (if (get msg "id")
                        msg
                        (assoc msg "id" (str (System/currentTimeMillis))))]

      ;; Print client message in verbose mode
      (when (:verbose opts)
        (pp/pprint msg-with-id))

      (bencode/write-bencode out msg-with-id)
      (.flush out)

      ;; Collect all response messages until we get "done" status or no status
      (loop [responses []
             timeout-count 0]
        (let [response (bencode/read-bencode in)
              _ (when (:verbose opts) (pp/pprint (->str-deep response)))
              status-set (some->> (get response "status") (map ->str) set)]
          (cond
            (contains? status-set "done")
            (do
              (.close socket)
              (if (:verbose opts)
                responses ; Return empty since we already printed
                (conj responses response)))

            ;; For operations that don't return "done", stop after reasonable response count
            (> timeout-count 10)
            (do
              (.close socket)
              responses)

            ;; Otherwise keep reading
            :else
            (recur (if (:verbose opts)
                     responses ; Don't accumulate in verbose mode
                     (conj responses response))
                   (inc timeout-count))))))

    (catch Exception e
      (println "Error sending message to nREPL server at" (str host ":" port))
      (println (.getMessage e))
      (System/exit 1))))

(defn process-raw-message [host port message-str opts]
  (let [responses (send-raw-message host port message-str opts)]
    ;; In verbose mode, everything was already printed
    (when-not (:verbose opts)
      (doseq [resp responses]
        (pp/pprint (->str-deep resp))))))

(defn -main [& args]
  (let [opts (cli/parse-opts args {:spec cli-spec})
        host (resolve-host (:h opts))
        port (resolve-port (:p opts) (:f opts))]

    (validate-args opts)

    (when-not port
      (println "Error: No port specified, no .nrepl-port file found, and BREPL_PORT not set")
      (System/exit 1))

    (let [result (cond
                   (:e opts) (eval-expression host port (:e opts) opts)
                   (:f opts) (eval-file host port (:f opts) opts)
                   (:m opts) (do (process-raw-message host port (:m opts) opts)
                                 false))] ; raw messages don't track errors

      ;; Handle hook mode
      (if (:hook opts)
        (let [{:keys [processed has-error?]} result
              hook-response (format-hook-response processed has-error?)]
          (println (json/generate-string hook-response))
          (System/exit (if has-error? 2 0)))

        ;; Regular mode - for backward compatibility, use exit code 2 for eval errors
        (when result
          (System/exit 2))))))

(defn debug-log [msg]
  (spit "/tmp/brepl-hook-debug.log"
        (str (java.time.LocalDateTime/now) " - " msg "\n")
        :append true))

(defn json-exit [response exit-code]
  (println (json/generate-string response))
  (System/exit exit-code))

(defn block-hook
  ([reason] (block-hook "PreToolUse" reason))
  ([event-name reason]
   (json-exit {:hookSpecificOutput
               {:hookEventName event-name
                :permissionDecision "deny"
                :permissionDecisionReason reason}} 1)))

(defn allow-hook
  ([] (json-exit {:hookSpecificOutput
                  {:hookEventName "PreToolUse"
                   :permissionDecision "allow"}} 0))
  ([event-name] (json-exit {:hookSpecificOutput
                             {:hookEventName event-name
                              :permissionDecision "allow"}} 0))
  ([tool-name tool-input fixed-content]
   (let [updated-input (case tool-name
                         "Edit" (assoc tool-input :new_string fixed-content)
                         "Write" (assoc tool-input :content fixed-content)
                         tool-input)]
     (json-exit {:hookSpecificOutput
                 {:hookEventName "PreToolUse"
                  :permissionDecision "allow"
                  :permissionDecisionReason "Auto-fixed bracket errors"
                  :updatedInput updated-input}} 0))))

;; Hook subcommand handlers
(defn get-file-path-from-stdin []
  (try
    (let [file-path (-> (json/parse-stream *in* true)
                        :tool_input
                        :file_path)]
      (debug-log (str "eval hook called for: " file-path))
      file-path)
    (catch Exception e
      (debug-log (str "ERROR parsing stdin: " (.getMessage e)))
      nil)))

(defn get-hook-input [args]
  (if (>= (count args) 2)
    [(first args) (second args) nil nil]
    (try
      (let [{:keys [tool_name tool_input]} (json/parse-stream *in* true)
            {:keys [file_path content old_string new_string]} tool_input]
        (debug-log (str "Hook called - Tool: " tool_name " File: " file_path))
        (case tool_name
          "Write"  [file_path content tool_name tool_input]
          ;; For Edit: validate just the replacement text (new_string), not the full file
          "Edit"   [file_path new_string tool_name tool_input]
          [nil nil nil nil]))
      (catch Exception e
        (debug-log (str "ERROR parsing stdin: " (.getMessage e)))
        [nil nil nil nil]))))

(defn handle-validate [args]
  (let [[file-path content tool-name tool-input] (get-hook-input args)]
    (when (or (nil? file-path) (nil? content))
      (block-hook "Could not parse hook input"))

    (when-not (validator/clojure-file? file-path)
      (allow-hook))

    (if-let [error (validator/delimiter-error? content)]
      (if-let [fixed (validator/auto-fix-brackets content)]
        (do (when-let [session-id (System/getenv "SESSION_ID")]
              (backup/create-backup file-path session-id))
            (allow-hook tool-name tool-input fixed))
        (block-hook (str "Syntax error in " file-path ": "
                         (validator/format-error-message error file-path))))
      (do (when-let [session-id (System/getenv "SESSION_ID")]
            (backup/create-backup file-path session-id))
          (allow-hook)))))

(defn handle-eval [args]
  (let [file-path (if (empty? args) (get-file-path-from-stdin) (first args))]
    (when (nil? file-path)
      (block-hook "PostToolUse" "Could not get file path"))

    (when-not (.exists (io/file file-path))
      (block-hook "PostToolUse" (str "File not found: " file-path)))

    ;; Evaluate file via nREPL if available
    (if-let [port (resolve-port nil file-path)]
      (let [result (eval-file (resolve-host nil) port file-path {:hook true})]
        (if (:has-error? result)
          (json-exit {:hookSpecificOutput
                      {:hookEventName "PostToolUse"
                       :permissionDecision "allow"
                       :permissionDecisionReason (str "Evaluation error: "
                                                      (get-in result [:processed :ex] "Unknown error"))}} 0)
          (allow-hook "PostToolUse")))
      ;; No nREPL available, just allow
      (allow-hook "PostToolUse"))))

(defn handle-install [args]
  (let [opts (cli/parse-opts args {:spec {:strict-eval {:coerce :boolean}
                                           :parinfer {:coerce :boolean}}})
        status (installer/check-status)]
    (installer/install-hooks opts)
    (println "Installing Claude Code hooks...")
    (println "Hooks installed successfully.")
    (println)
    (when (:installed status)
      (println "Settings file:" (:settings-path status)))
    (System/exit 0)))

(defn handle-uninstall [_args]
  (installer/uninstall-hooks)
  (println "Removing Claude Code hooks...")
  (println "Hooks uninstalled successfully.")
  (System/exit 0))

(defn handle-session-end [args]
  (if (empty? args)
    (do (println "Error: session-id required")
        (System/exit 1))
    (do (backup/cleanup-session (first args))
        (System/exit 0))))

(defn show-hook-help [subcommand]
  (println "brepl hook - Claude Code integration commands")
  (println)
  (println "USAGE:")
  (println "    brepl hook validate <file> <content>")
  (println "    brepl hook eval <file>")
  (println "    brepl hook install [--strict-eval] [--parinfer]")
  (println "    brepl hook uninstall")
  (println "    brepl hook session-end <session-id>")
  (println)
  (println "SUBCOMMANDS:")
  (println "    validate       Validate Clojure file syntax before edit")
  (println "    eval           Evaluate file and check for runtime errors")
  (println "    install        Install hooks in .claude/settings.local.json")
  (println "    uninstall      Remove hooks from .claude/settings.local.json")
  (println "    session-end    Clean up session backup files")
  (System/exit (if (and subcommand
                        (not (contains? #{"validate" "eval" "install" "uninstall" "session-end"} subcommand)))
                 1 0)))

(defn handle-hook-subcommand [subcommand args]
  (case subcommand
    "validate"    (handle-validate args)
    "eval"        (handle-eval args)
    "install"     (handle-install args)
    "uninstall"   (handle-uninstall args)
    "session-end" (handle-session-end args)
    (show-hook-help subcommand)))

(defn -main-hook
  "Handle brepl hook subcommands"
  [args]
  (if (empty? args)
    (handle-hook-subcommand nil nil)
    (let [subcommand (first args)
          remaining-args (rest args)]
      (handle-hook-subcommand subcommand remaining-args))))

(when (= *file* (System/getProperty "babashka.file"))
  (if (and (> (count *command-line-args*) 0)
           (= "hook" (first *command-line-args*)))
    (-main-hook (rest *command-line-args*))
    (apply -main *command-line-args*)))
