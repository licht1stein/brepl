#!/usr/bin/env bb

(require '[babashka.cli :as cli]
         '[clojure.java.io :as io]
         '[clojure.string :as str]
         '[bencode.core :as bencode])

(import '[java.net Socket]
        '[java.io PushbackInputStream])

(def cli-spec
  {:e {:desc "Expression to evaluate"
       :ref "<expr>"}
   :f {:desc "File to load and execute"
       :ref "<file>"}
   :h {:desc "nREPL host"
       :ref "<host>"
       :default "localhost"
       :default-desc "localhost or BREPL_HOST"}
   :p {:desc "nREPL port (required - auto-detects from .nrepl-port or BREPL_PORT)"
       :ref "<port>"}
   :help {:desc "Show this help message"
          :alias :?}})

(defn print-help []
  (println "brepl - Fast Babashka nREPL client for one-shot code evaluation")
  (println)
  (println "USAGE:")
  (println "    brepl [OPTIONS] -e <expr>")
  (println "    brepl [OPTIONS] -f <file>")
  (println)
  (println "OPTIONS:")
  (println (cli/format-opts {:spec cli-spec :order [:e :f :h :p :help]}))
  (println)
  (println "PORT RESOLUTION:")
  (println "    Port is resolved in the following order:")
  (println "    1. -p <port> command line argument")
  (println "    2. .nrepl-port file in current directory")
  (println "    3. BREPL_PORT environment variable")
  (println "    4. Error if none found")
  (println)
  (println "EXAMPLES:")
  (println "    brepl -e \"(+ 1 2 3)\"")
  (println "    brepl -f script.clj")
  (println "    brepl -p 7888 -e \"(println \\\"Hello\\\")\"")
  (println "    BREPL_PORT=7888 brepl -e \"(+ 1 2)\""))

(defn read-nrepl-port []
  (when (.exists (io/file ".nrepl-port"))
    (-> (slurp ".nrepl-port")
        str/trim
        Integer/parseInt)))

(defn get-env-var [var-name]
  (System/getenv var-name))

(defn resolve-host [cli-host]
  (or cli-host (get-env-var "BREPL_HOST") "localhost"))

(defn resolve-port [cli-port]
  (or cli-port 
      (read-nrepl-port)
      (when-let [env-port (get-env-var "BREPL_PORT")]
        (Integer/parseInt env-port))))

(defn validate-args [opts]
  (when (:help opts)
    (print-help)
    (System/exit 0))
  
  (let [has-expr (contains? opts :e)
        has-file (contains? opts :f)]
    (cond
      (and has-expr has-file)
      (do (println "Error: Cannot specify both -e and -f")
          (println)
          (print-help)
          (System/exit 1))
      
      (not (or has-expr has-file))
      (do (println "Error: Must specify either -e EXPR or -f FILE")
          (println)
          (print-help)
          (System/exit 1))
      
      (and has-file (not (.exists (io/file (:f opts)))))
      (do (println "Error: File does not exist:" (:f opts))
          (System/exit 1)))))

;; nREPL client implementation
(defn bytes->str [x]
  (if (bytes? x) (String. x) x))

(defn send-eval-message [host port code]
  (let [socket (Socket. host port)
        out (.getOutputStream socket)
        in (PushbackInputStream. (.getInputStream socket))
        msg-id (str (System/currentTimeMillis))
        msg {"op" "eval"
             "code" code
             "id" msg-id}]
    (bencode/write-bencode out msg)
    (.flush out)
    
    ;; Collect all response messages until we get "done" status
    (loop [responses []]
      (let [response (bencode/read-bencode in)
            status (get response "status")
            status-strs (when status
                          (if (coll? status)
                            (map #(if (bytes? %) (String. %) %) status)
                            [(if (bytes? status) (String. status) status)]))]
        (if (and status-strs (some #(= % "done") status-strs))
          (do
            (.close socket)
            (conj responses response))
          (recur (conj responses response)))))))

(defn process-eval-responses [responses]
  (let [combined {:out []
                  :err []
                  :values []
                  :ex nil
                  :status []}]
    (reduce (fn [acc resp]
              (cond-> acc
                (get resp "out") (update :out conj (bytes->str (get resp "out")))
                (get resp "err") (update :err conj (bytes->str (get resp "err")))
                (get resp "value") (update :values conj (bytes->str (get resp "value")))
                (get resp "ex") (assoc :ex (bytes->str (get resp "ex")))
                (get resp "status") (update :status into 
                                            (map bytes->str 
                                                 (if (coll? (get resp "status"))
                                                   (get resp "status")
                                                   [(get resp "status")])))))
            combined
            responses)))

(defn eval-expression [host port code]
  (try
    (let [responses (send-eval-message host port code)
          processed (process-eval-responses responses)]
      
      ;; Print stdout output
      (doseq [out (:out processed)]
        (print out))
      
      ;; Print stderr output to stderr
      (doseq [err (:err processed)]
        (binding [*out* *err*]
          (print err)))
      
      ;; Print evaluation results
      (doseq [val (:values processed)]
        (println val))
      
      ;; Handle exceptions
      (when (:ex processed)
        (binding [*out* *err*]
          (println "Exception:" (:ex processed))))
      
      ;; Handle empty response
      (when (and (empty? (:values processed))
                 (empty? (:out processed))
                 (empty? (:err processed))
                 (not (:ex processed)))
        (when (some #{"eval-error"} (flatten (:status processed)))
          (binding [*out* *err*]
            (println "Evaluation error occurred")))))
    
    (catch Exception e
      (println "Error connecting to nREPL server at" (str host ":" port))
      (println (.getMessage e))
      (System/exit 1))))

(defn load-file [host port file-path]
  (let [code (slurp file-path)]
    (eval-expression host port code)))

(defn -main [& args]
  (let [opts (cli/parse-opts args {:spec cli-spec})
        host (resolve-host (:h opts))
        port (resolve-port (:p opts))]
    
    (validate-args opts)
    
    (when-not port
      (println "Error: No port specified, no .nrepl-port file found, and BREPL_PORT not set")
      (System/exit 1))
    
    (cond
      (:e opts) (eval-expression host port (:e opts))
      (:f opts) (load-file host port (:f opts)))))

(when (= *file* (System/getProperty "babashka.file"))
  (apply -main *command-line-args*))